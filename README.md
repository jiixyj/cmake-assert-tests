# cmake-assert-tests

This repo contains an example of how "assert style" tests can be done with
CMake and its test runner, CTest. In contrast to test frameworks like GTest or
Catch2, "assert style" tests just have a simple `int main()` entrypoint and use
`assert()` from `<assert.h>` for doing assertions.

## Usage

Most projects either place their tests next to the source code (dubbed "Merged
Test Placement" by the
[Pitchfork layout conventions](<https://web.archive.org/web/20231210061404/https://api.csswg.org/bikeshed/?force=1&url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#src.tests>),
or place them all into a different top-level folder like `tests/` ("Separate
Test Placement").

For merged test placement, put all your tests into a subfolder with a `.test`
suffix next to the module/component you want to test. Then, include the
`TestHelpers.cmake` script in your CMakeLists.txt and add the tests like this:

```cmake
include(TestHelpers)

test_helpers_glob_for_tests(_tests)
foreach(_test IN LISTS _tests)
    test_helpers_add_simple_assert_test("${_test}" LIBRARIES testlib::testlib)
endforeach()
```

Replace `testlib::testlib` with the libraries your test targets need.

See the `src/` folder for examples.

For separate test placement, the CMake code looks more or less the same, but
needs the `SEPARATED_PLACEMENT` option to a few functions:

```cmake
include(TestHelpers)

test_helpers_glob_for_tests(_tests SEPARATED_PLACEMENT)
foreach(_test IN LISTS _tests)
    test_helpers_add_simple_assert_test("${_test}" SEPARATED_PLACEMENT
        LIBRARIES testlib::testlib
    )
endforeach()
```

See the `tests/` folder for an example.

The scripts will find the tests and register them with CTest:

```txt
$ ctest -N
Test project /dev/cmake-assert-tests/build
  Test #1: testlib:include.compile.pass
  Test #2: testlib.add:add.pass
  Test #3: testlib.add:constexpr_add.pass
  Test #4: testlib.add:constructor.compile.fail
  Test #5: testlib.add:constructor.compile.pass
  Test #6: testlib.add:constructor.verify
  Test #7: testlib.fibonacci:fibonacci.pass
  Test #8: testlib/add/add.pass

Total Tests: 8
```

In the example above, tests 1-7 come from merged test placement, while test 8
comes from separated test placement.

## Supported Test Types

libc++'s lit style assertion tests support a range of different test types that
are distinguished by their file suffix:

- `.pass.cpp`: A "normal" test that runs some asserts and succeeds if the test
  executable returns "0" as the exit code.
- `.compile.pass.cpp`: The test succeeds if the code can be compiled
  successfully.
- `.compile.fail.cpp`: The test succeeds if the code does not compile.
- `.verify.cpp`: The test succeeds if compiling the code with the Clang
  compiler results in the expected compiler notes/warnings/errors.

There are a few more, but those four types are supported right now.

## CTest Test Naming

For merged test placement, the test name consists of the component/module name
with hierarchy indicated by a period, a colon, and then the path to the test
case, without the trailing `.cpp`:

```txt
testlib.add:constructor.compile.fail
\---------/ \----------------------/
   |                          |
   +--- component name        +--- path to test case
```

In case of separated test placement, the whole name is just the path to the
test case:

```txt
testlib/add/add.pass
\------------------/
   |
   +--- path to test case
```

This naming scheme ensures there won't be any collisions, even when mixing
merged and separate test placement.

## Globbing for Tests

With "normal" test frameworks like GTest or Catch2, one test driver will
usually contain multiple test cases. The test framework will ask the test
driver for the list of test cases it contains and register them with CTest.

With "assert style" tests this is not possible as there is exactly one test
executable per test case.

Listing all test files/cases in the `CMakeLists.txt` would quickly become a
hassle, though. To solve this in a robust way CMake provides the
`CONFIGURE_DEPENDS` flag to `file(GLOB)`. When using this flag, one can add
more test cases even after the build system was generated by CMake, as there
will be a build rule that scans for new tests every time you run the generated
build system. If this overhead is too much, you can list all tests manually of
course. CMake's
[`file()` documentation](<https://cmake.org/cmake/help/latest/command/file.html#glob>)
has a good discussion on the drawbacks of using globbing.

## Handling of NDEBUG

`assert()` only works when `NDEBUG` is _not_ defined. Some of CMake's default
build types like "Release" or "RelWithDebInfo" define this by default. The
TestHelpers scripts make sure this is getting undefined for the tests by
force including a header that does a `#undef NDEBUG`. The CMake variable
`CMAKE_CXX_FLAGS` is not touched as that is discouraged by CMake and more
brittle in comparison.

## Compile Tests

The compile tests (`.verify`, `.compile.{pass,fail}`) work by enabling the
required compiler flags like `-verify` or `-fsyntax-only` and stubbing out the
linker command so that it always succeeds but provides no output. The CMake
target corresponding to the test case is excluded from the default build and
built by `cmake --build . --target <target>` during test execution.

Only Clang can execute the `.verify` tests. On other compilers, the
corresponding test cases show up as "disabled" in CTest.

## C++20 Modules

Structuring tests like this will also work with C++20 modules. The only
difference is that you have `.cppm` files instead of `.h` files and are using
the `CXX_MODULES` file set on your library target instead of the `HEADERS` one.
